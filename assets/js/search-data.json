{
  
    
        "post0": {
            "title": "fastai ULMFit approach performance versus standard NLP Pytorch model",
            "content": "Introduction . In this project we will be comparing the results from a sentiment analysis model using a RNN implemented directly in PyTorch with another using the Fastai library with the ULMFit (Universal Language Model Fine-tuning) approach from this paper. . The ULMFit approach involves using a language model first and then train it with the new vocabulary from the new application. Once our language model has been trained with the added new data, we use it as the base from our classification problem. A language model is a model that has been trained to guess the next word coming in a text from having seen the words that came before. This kind of process is called self supervized learning. In this case, no labels are provided to our model. . Lets move onto the actual classification problem we are going to solve. . When deciding the value of a company, it&#39;s important to follow the news. For example, a product recall or natural disaster in a company&#39;s product chain. You want to be able to turn this information into a signal. . We will be using posts from the social media site StockTwits. The community on StockTwits is full of investors, traders, and entrepreneurs. Each message posted is called a Twit. This is similar to Twitter&#39;s version of a post, called a Tweet. We will build a model around these twits that generate a sentiment score. . The data is a large collection of messages that where hand labeled with the sentiment of each. The degree of sentiment is a five-point scale: very negative, negative, neutral, positive, very positive. Each twit is labeled -2 to 2 in steps of 1, from very negative to very positive respectively. . The first thing we should to do, is load the data. . Import Twits . Load Twits Data . This JSON file contains a list of objects for each twit in the &#39;data&#39; field: . {&#39;data&#39;: {&#39;message_body&#39;: &#39;Neutral twit body text here&#39;, &#39;sentiment&#39;: 0}, {&#39;message_body&#39;: &#39;Happy twit body text here&#39;, &#39;sentiment&#39;: 1}, ... } . The fields represent the following: . &#39;message_body&#39;: The text of the twit. | &#39;sentiment&#39;: Sentiment score for the twit, ranges from -2 to 2 in steps of 1, with 0 being neutral. | . To see what the data look like by printing the first 10 twits from the list. . from fastai.text.all import * . with open(os.path.join(&#39;data&#39;, &#39;stocktwits_sentiment&#39;, &#39;twits.json&#39;), &#39;r&#39;) as f: twits = json.load(f) . Length of data . Lets look at the length of our data: . print(len(twits[&#39;data&#39;])) . 1548010 . And a couple of messages . print(twits[&#39;data&#39;][:5]) . [{&#39;message_body&#39;: &#39;$FITB great buy at 26.00...ill wait&#39;, &#39;sentiment&#39;: 2, &#39;timestamp&#39;: &#39;2018-07-01T00:00:09Z&#39;}, {&#39;message_body&#39;: &#39;@StockTwits $MSFT&#39;, &#39;sentiment&#39;: 1, &#39;timestamp&#39;: &#39;2018-07-01T00:00:42Z&#39;}, {&#39;message_body&#39;: &#39;#STAAnalystAlert for $TDG : Jefferies Maintains with a rating of Hold setting target price at USD 350.00. Our own verdict is Buy http://www.stocktargetadvisor.com/toprating&#39;, &#39;sentiment&#39;: 2, &#39;timestamp&#39;: &#39;2018-07-01T00:01:24Z&#39;}, {&#39;message_body&#39;: &#39;$AMD I heard there‚Äôs a guy who knows someone who thinks somebody knows something - on StockTwits.&#39;, &#39;sentiment&#39;: 1, &#39;timestamp&#39;: &#39;2018-07-01T00:01:47Z&#39;}, {&#39;message_body&#39;: &#39;$AMD reveal yourself!&#39;, &#39;sentiment&#39;: 0, &#39;timestamp&#39;: &#39;2018-07-01T00:02:13Z&#39;}] . Lets split the messages and the labels . messages = [twit[&#39;message_body&#39;] for twit in twits[&#39;data&#39;]] # Since the sentiment scores are discrete, we&#39;ll scale the sentiments to 0 to 4 for use in our network sentiments = [twit[&#39;sentiment&#39;] + 2 for twit in twits[&#39;data&#39;]] . messages[45], sentiments[45] . (&#39;$NFLX just noticed they have the last jedi on stream. Love this stock&#39;, 2) . Preprocessing the Data . With our data in hand we need to preprocess our text. These twits are collected by filtering on ticker symbols where these are denoted with a leader $ symbol in the twit itself. For example, . {&#39;message_body&#39;: &#39;RT @google Our annual look at the year in Google blogging (and beyond) http://t.co/sptHOAh8 $GOOG&#39;, &#39;sentiment&#39;: 0} . The ticker symbols don&#39;t provide information on the sentiment, and they are in every twit, so we should remove them. This twit also has the @google username, again not providing sentiment information, so we should also remove it. We also see a URL http://t.co/sptHOAh8. Let&#39;s remove these too. . import json import nltk import os import random import re import torch from torch import nn, optim import torch.nn.functional as F . nltk.download(&#39;wordnet&#39;) def preprocess_1(message): &quot;&quot;&quot; This function takes a string as input, then performs these operations: - lowercase - remove URLs - remove ticker symbols - removes punctuation - tokenize by splitting the string on whitespace - removes any single character tokens Parameters - message : The text message to be preprocessed. Returns - tokens: The preprocessed text into tokens. &quot;&quot;&quot; # Lowercase the twit message text = message.lower() # Replace URLs with a space in the message text = re.sub(r&#39;https?://[^ s]+&#39;, &#39; &#39;, text) # Replace ticker symbols with a space. The ticker symbols are any stock symbol that starts with $. text = re.sub(r&#39; $[a-z]* b&#39;, &#39; &#39;, text) # Replace StockTwits usernames with a space. The usernames are any word that starts with @. text = re.sub(r&#39;@ w* b&#39;, &#39; &#39;, text) # Replace everything not a letter with a space text = re.sub(r&#39;[^a-z]&#39;, &#39; &#39;, text) # Tokenize by splitting the string on whitespace into a list of words tokens = text.split() # Lemmatize words using the WordNetLemmatizer. You can ignore any word that is not longer than one character. wnl = nltk.stem.WordNetLemmatizer() tokens = [wnl.lemmatize(t) for t in tokens if len(t) &gt; 1] return tokens . [nltk_data] Downloading package wordnet to /root/nltk_data... [nltk_data] Unzipping corpora/wordnet.zip. . Preprocess All the Twits . tokenized = [preprocess_1(m) for m in messages] . tokenized[:1], messages[:1] . ([[&#39;great&#39;, &#39;buy&#39;, &#39;at&#39;, &#39;ill&#39;, &#39;wait&#39;]], [&#39;$FITB great buy at 26.00...ill wait&#39;]) . Looking good . Lets check for empty tokens . len([token for token in tokenized if len(token) == 0]) . 48528 . Clean that up . good_tokens = [idx for idx, token in enumerate(tokenized) if len(token) &gt; 0] tokenized = [tokenized[idx] for idx in good_tokens] sentiments = [sentiments[idx] for idx in good_tokens] . Bag of Words . Now with all of our messages tokenized, we want to create a vocabulary and count up how often each word appears in our entire corpus. . from collections import Counter &quot;&quot;&quot; Create a vocabulary by using Bag of words &quot;&quot;&quot; stacked_tokens = [word for twit in tokenized for word in twit] bow = Counter(stacked_tokens) # sort by decreasing order sorted_bow = sorted(bow, key=bow.get, reverse=True) . Frequency of Words Appearing in Message . With our vocabulary parsed, lets remove some of the most common words such as &#39;the&#39;, &#39;and&#39;, &#39;it&#39;, etc. These words don&#39;t contribute to identifying sentiment and are really common, resulting in a lot of noise in our input. If we can filter these out, then our network should have an easier time learning. . We also want to remove really rare words that show up only in a few twits. Here you&#39;ll want to divide the count of each word by the number of messages. Then remove words that only appear in some small fraction of the messages. . # The key is the token and the value is the frequency of that word in the corpus. total_words = len(bow) freqs = {word: count/total_words for word, count in bow.items()} # Float that is the frequency cutoff. Drop words with a frequency that is lower or equal to this number. low_cutoff = 1e-5 # Integer that is the cut off for most common words. Drop words that are the `high_cutoff` most common words. high_cutoff = 15 # The k most common words in the corpus. Use `high_cutoff` as the k. K_most_common = [word[0] for word in bow.most_common(high_cutoff)] filtered_words = [word for word in freqs if (freqs[word] &gt; low_cutoff and word not in K_most_common)] print(K_most_common) len(filtered_words) . [&#39;the&#39;, &#39;to&#39;, &#39;is&#39;, &#39;for&#39;, &#39;on&#39;, &#39;of&#39;, &#39;and&#39;, &#39;in&#39;, &#39;this&#39;, &#39;it&#39;, &#39;at&#39;, &#39;will&#39;, &#39;up&#39;, &#39;are&#39;, &#39;you&#39;] . 98448 . Remove Filtered Words from Vocabulary . from tqdm import tqdm # A dictionary for the `filtered_words`. The key is the word and value is an id that represents the word. vocab = {word: i for i, word in enumerate(filtered_words, 1)} # Reverse of the `vocab` dictionary. The key is word id and value is the word. id2vocab = {i: word for i, word in enumerate(filtered_words, 1)} # tokenized with the words not in `filtered_words` removed. filtered = [ [w for w in msg if w in filtered_words] for msg in tqdm(tokenized) ] . 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1499482/1499482 [2:13:51&lt;00:00, 186.69it/s] . Balancing the classes . If we look at how our twits are labeled, we&#39;ll find that 50% of them are neutral. This means that our network will be 45% accurate just by guessing 0 every single time. To help our network learn appropriately, we&#39;ll want to balance our classes. That is, make sure each of our different sentiment scores show up roughly as frequently in the data. . What we can do here is go through each of our examples and randomly drop twits with neutral sentiment. We want to get around 20% neutral twits starting from 50% neutral. . for i in range(0,5): print(f&#39;{i}: {sentiments.count(i)/len(sentiments)}&#39;) . 0: 0.08710474683924181 1: 0.11403071193918966 2: 0.44561321843143165 3: 0.20476004380179288 4: 0.14849127898834397 . balanced = {&#39;messages&#39;: [], &#39;sentiments&#39;:[]} n_neutral = sum(1 for each in sentiments if each == 2) N_examples = len(sentiments) keep_prob = (N_examples - n_neutral)/4/n_neutral print(f&#39;keep_prob: {keep_prob}&#39;) for idx, sentiment in enumerate(sentiments): message = filtered[idx] if sentiment != 2 or random.random() &lt; keep_prob: balanced[&#39;messages&#39;].append(message) balanced[&#39;sentiments&#39;].append(sentiment) . keep_prob: 0.31102465021124265 . Lets check that we are balanced: . n_neutral = sum(1 for each in balanced[&#39;sentiments&#39;] if each == 2) N_examples = len(balanced[&#39;sentiments&#39;]) n_neutral/N_examples . 0.1998550428903639 . Looks good, 1/5th of our samples are neutral now. . Let&#39;s convert our tokens into integer ids which we can pass to the network. . token_ids = [[vocab[word] for word in message] for message in balanced[&#39;messages&#39;]] sentiments = balanced[&#39;sentiments&#39;] . Neural Network . With our vocabulary mapped to interger ids, we are now ready to build our neural network. . Here is a diagram showing the network: . Embed -&gt; RNN -&gt; Dense -&gt; Softmax . class TextClassifier(nn.Module): def __init__(self, vocab_size, embed_size, lstm_size, output_size, lstm_layers=1, dropout=0.1): &quot;&quot;&quot; Initialize the model by setting up the layers. Parameters - vocab_size : The vocabulary size. embed_size : The embedding layer size. lstm_size : The LSTM layer size. output_size : The output size. lstm_layers : The number of LSTM layers. dropout : The dropout probability. &quot;&quot;&quot; super().__init__() self.vocab_size = vocab_size self.embed_size = embed_size self.lstm_size = lstm_size self.output_size = output_size self.lstm_layers = lstm_layers self.dropout = dropout # Setup embedding layer self.embedding = nn.Embedding(vocab_size, embed_size) self.lstm = nn.LSTM(embed_size, lstm_size, lstm_layers, dropout=dropout, batch_first=False) # Setup additional layers self.dropout = nn.Dropout(dropout) self.fc = nn.Linear(lstm_size, output_size) self.logsoftmax = nn.LogSoftmax(dim=1) def init_hidden(self, batch_size): &quot;&quot;&quot; Initializes hidden state Parameters - batch_size : The size of batches. Returns - hidden_state &quot;&quot;&quot; # Create two new tensors with sizes n_layers x batch_size x hidden_dim, # initialized to zero, for hidden state and cell state of LSTM weight = next(self.parameters()).data hidden = (weight.new(self.lstm_layers, batch_size, self.lstm_size).zero_(), weight.new(self.lstm_layers, batch_size, self.lstm_size).zero_()) return hidden def forward(self, nn_input, hidden_state): &quot;&quot;&quot; Perform a forward pass of our model on nn_input. Parameters - nn_input : The batch of input to the NN. hidden_state : The LSTM hidden state. Returns - logps: log softmax output hidden_state: The new hidden state. &quot;&quot;&quot; # embeddings and lstm_out nn_input = nn_input.long() embeds = self.embedding(nn_input) lstm_out, hidden_state = self.lstm(embeds, hidden_state) lstm_out = lstm_out[-1, : , :] # dropout and fully-connected layer out = self.dropout(lstm_out) out = self.fc(out) logps = self.logsoftmax(out) return logps, hidden_state . View Model . model = TextClassifier(len(vocab), 10, 6, 5, dropout=0.1, lstm_layers=2) model.embedding.weight.data.uniform_(-1, 1) input = torch.randint(0, 1000, (5, 4), dtype=torch.int64) hidden = model.init_hidden(4) logps, _ = model.forward(input, hidden) print(logps) print(model) . tensor([[-2.0672, -1.8099, -1.3161, -1.5152, -1.5058], [-2.0718, -1.7388, -1.3464, -1.5252, -1.5115], [-2.0702, -1.7568, -1.3375, -1.5287, -1.5054], [-2.0329, -1.9265, -1.2760, -1.5094, -1.4997]], grad_fn=&lt;LogSoftmaxBackward&gt;) TextClassifier( (embedding): Embedding(98448, 10) (lstm): LSTM(10, 6, num_layers=2, dropout=0.1) (dropout): Dropout(p=0.1, inplace=False) (fc): Linear(in_features=6, out_features=5, bias=True) (logsoftmax): LogSoftmax(dim=1) ) . Training . DataLoaders and Batching . Now we should build a generator that we can use to loop through our data. It&#39;ll be more efficient if we can pass our sequences in as batches. Our input tensors should look like (sequence_length, batch_size). So if our sequences are 40 tokens long and we pass in 25 sequences, then we&#39;d have an input size of (40, 25). . If we set our sequence length to 40, what do we do with messages that are more or less than 40 tokens? For messages with fewer than 40 tokens, we will pad the empty spots with zeros. We should be sure to left pad so that the RNN starts from nothing before going through the data. If the message has 20 tokens, then the first 20 spots of our 40 long sequence will be 0. If a message has more than 40 tokens, we&#39;ll just keep the first 40 tokens. . def dataloader(messages, labels, sequence_length=30, batch_size=32, shuffle=False): &quot;&quot;&quot; Build a dataloader. &quot;&quot;&quot; if shuffle: indices = list(range(len(messages))) random.shuffle(indices) messages = [messages[idx] for idx in indices] labels = [labels[idx] for idx in indices] total_sequences = len(messages) for ii in range(0, total_sequences, batch_size): batch_messages = messages[ii: ii+batch_size] # First initialize a tensor of all zeros batch = torch.zeros((sequence_length, len(batch_messages)), dtype=torch.int64) for batch_num, tokens in enumerate(batch_messages): token_tensor = torch.tensor(tokens) # Left pad! start_idx = max(sequence_length - len(token_tensor), 0) batch[start_idx:, batch_num] = token_tensor[:sequence_length] label_tensor = torch.tensor(labels[ii: ii+len(batch_messages)]) yield batch, label_tensor . Training and Validation . Split it into training and validation sets. . split_frac = 0.8 split_idx = int(len(token_ids)*split_frac) train_features, valid_features = token_ids[:split_idx], token_ids[split_idx:] train_labels, valid_labels = sentiments[:split_idx], sentiments[split_idx:] . text_batch, labels = next(iter(dataloader(train_features, train_labels, sequence_length=20, batch_size=64))) model = TextClassifier(len(vocab)+1, 200, 128, 5, dropout=0.) hidden = model.init_hidden(64) logps, hidden = model.forward(text_batch, hidden) . Train model . device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) model = TextClassifier(len(vocab)+1, 1024, 512, 5, lstm_layers=2, dropout=0.2) model.embedding.weight.data.uniform_(-1, 1) model.to(device) . TextClassifier( (embedding): Embedding(98449, 1024) (lstm): LSTM(1024, 512, num_layers=2, dropout=0.2) (dropout): Dropout(p=0.2, inplace=False) (fc): Linear(in_features=512, out_features=5, bias=True) (logsoftmax): LogSoftmax(dim=1) ) . &quot;&quot;&quot; Train your model with dropout. Make sure to clip your gradients. Print the training loss, validation loss, and validation accuracy for every 100 steps. &quot;&quot;&quot; epochs = 3 batch_size = 1024 learning_rate = .001 clip = 5 print_every = 100 criterion = nn.NLLLoss() optimizer = optim.Adam(model.parameters(), lr=learning_rate) model.train() train_losses = [] valid_losses = [] valid_accs = [] for epoch in range(epochs): print(&#39;Starting epoch {}&#39;.format(epoch + 1)) steps = 0 for text_batch, labels in dataloader( train_features, train_labels, batch_size=batch_size, sequence_length=20, shuffle=True): steps += 1 # initialize hidden state hidden = model.init_hidden(batch_size=labels.shape[0]) # Set Device text_batch, labels = text_batch.to(device), labels.to(device) for each in hidden: each.to(device) # reset gradients model.zero_grad() # get output from model log_probs, hidden = model(text_batch, hidden) # calculate the loss and perform backprop loss = criterion(log_probs, labels) loss.backward() # `clip_grad_norm` helps prevent the exploding gradient problem in RNNs / LSTMs. nn.utils.clip_grad_norm_(model.parameters(), clip) optimizer.step() if steps % print_every == 0: model.eval() # Get validation loss val_losses = [] for text_batch, labels in dataloader(valid_features, valid_labels, batch_size=batch_size, sequence_length=20, shuffle=True): val_hidden = model.init_hidden(labels.shape[0]) text_batch, labels = text_batch.to(device), labels.to(device) for each in val_hidden: each.to(device) val_log_probs, test_hidden = model(text_batch, val_hidden) valid_loss = criterion(val_log_probs, labels) # Accuracy probs = torch.exp(val_log_probs) top_prob, top_class = probs.topk(1) equality = top_class == labels.view(*top_class.shape) valid_acc = torch.mean(equality.type(torch.FloatTensor)) train_losses.append(loss.item()) valid_losses.append(valid_loss.item()) valid_accs.append(valid_acc.item()) model.train() print(f&#39;Epoch: {epoch+1} / {epochs} tStep: {steps}&#39;, f&#39; n Train Loss: {loss.item():.3f}&#39;, f&#39; Validation Loss: {valid_loss.item():.3f}&#39;, f&#39; Validation Accy: {valid_acc.item():.3f}&#39;) . Starting epoch 1 Epoch: 1 / 3 Step: 100 Train Loss: 0.913 Validation Loss: 0.956 Validation Accy: 0.634 Epoch: 1 / 3 Step: 200 Train Loss: 0.856 Validation Loss: 0.877 Validation Accy: 0.658 Epoch: 1 / 3 Step: 300 Train Loss: 0.781 Validation Loss: 0.841 Validation Accy: 0.670 Epoch: 1 / 3 Step: 400 Train Loss: 0.783 Validation Loss: 0.724 Validation Accy: 0.716 Epoch: 1 / 3 Step: 500 Train Loss: 0.745 Validation Loss: 0.761 Validation Accy: 0.713 Epoch: 1 / 3 Step: 600 Train Loss: 0.738 Validation Loss: 0.706 Validation Accy: 0.725 Epoch: 1 / 3 Step: 700 Train Loss: 0.722 Validation Loss: 0.688 Validation Accy: 0.746 Epoch: 1 / 3 Step: 800 Train Loss: 0.730 Validation Loss: 0.752 Validation Accy: 0.714 Starting epoch 2 Epoch: 2 / 3 Step: 100 Train Loss: 0.640 Validation Loss: 0.747 Validation Accy: 0.738 Epoch: 2 / 3 Step: 200 Train Loss: 0.652 Validation Loss: 0.780 Validation Accy: 0.706 Epoch: 2 / 3 Step: 300 Train Loss: 0.689 Validation Loss: 0.756 Validation Accy: 0.694 Epoch: 2 / 3 Step: 400 Train Loss: 0.686 Validation Loss: 0.753 Validation Accy: 0.722 Epoch: 2 / 3 Step: 500 Train Loss: 0.679 Validation Loss: 0.722 Validation Accy: 0.722 Epoch: 2 / 3 Step: 600 Train Loss: 0.674 Validation Loss: 0.746 Validation Accy: 0.701 Epoch: 2 / 3 Step: 700 Train Loss: 0.680 Validation Loss: 0.720 Validation Accy: 0.715 Epoch: 2 / 3 Step: 800 Train Loss: 0.683 Validation Loss: 0.683 Validation Accy: 0.729 Starting epoch 3 Epoch: 3 / 3 Step: 100 Train Loss: 0.600 Validation Loss: 0.756 Validation Accy: 0.704 Epoch: 3 / 3 Step: 200 Train Loss: 0.602 Validation Loss: 0.733 Validation Accy: 0.731 Epoch: 3 / 3 Step: 300 Train Loss: 0.615 Validation Loss: 0.744 Validation Accy: 0.722 Epoch: 3 / 3 Step: 400 Train Loss: 0.625 Validation Loss: 0.716 Validation Accy: 0.719 Epoch: 3 / 3 Step: 500 Train Loss: 0.563 Validation Loss: 0.758 Validation Accy: 0.694 Epoch: 3 / 3 Step: 600 Train Loss: 0.663 Validation Loss: 0.760 Validation Accy: 0.716 Epoch: 3 / 3 Step: 700 Train Loss: 0.587 Validation Loss: 0.698 Validation Accy: 0.719 Epoch: 3 / 3 Step: 800 Train Loss: 0.666 Validation Loss: 0.689 Validation Accy: 0.716 . So we get about 72% accuracy on the validation set. Lets try the ULMFit approach . ULMFit approach . from fastai.text.all import * . Starting from scratch . with open(os.path.join(&#39;data&#39;, &#39;stocktwits_sentiment&#39;, &#39;twits.json&#39;), &#39;r&#39;) as f: twits = json.load(f) . messages = [twit[&#39;message_body&#39;] for twit in twits[&#39;data&#39;]] # Since the sentiment scores are discrete, we&#39;ll scale the sentiments to 0 to 4 for use in our network sentiments = [twit[&#39;sentiment&#39;] + 2 for twit in twits[&#39;data&#39;]] . For the preprocess step, fastai does a lot of the work for us using the Spacy tokenizer by default. We keep track of uppercase letters so we do not lowercase everything. Our preprocess function is therefore simplified. . def preprocess(message): text = message # Replace URLs with a space in the message text = re.sub(r&#39;https?://[^ s]+&#39;, &#39; &#39;, text) # Replace ticker symbols with a space. The ticker symbols are any stock symbol that starts with $. text = re.sub(r&#39; $[a-zA-Z]* b&#39;, &#39; &#39;, text) # Replace StockTwits usernames with a space. The usernames are any word that starts with @. text = re.sub(r&#39;@ w* b&#39;, &#39; &#39;, text) # Replace everything not a letter with a space text = re.sub(r&#39;[^a-zA-Z]&#39;, &#39; &#39;, text) # Remove multiple spaces text = &#39; &#39;.join(text.split()) # Tokenize by splitting the string on whitespace into a list of words #tokens = text.split() # Lemmatize words using the WordNetLemmatizer. You can ignore any word that is not longer than one character. # wnl = nltk.stem.WordNetLemmatizer() # tokens = [wnl.lemmatize(t) for t in tokens if len(t) &gt; 1] return text . messages_clean = [preprocess(m) for m in messages] . messages_clean[:10], sentiments[:10] . ([&#39;great buy at ill wait&#39;, &#39;&#39;, &#39;STAAnalystAlert for Jefferies Maintains with a rating of Hold setting target price at USD Our own verdict is Buy&#39;, &#39;I heard there s a guy who knows someone who thinks somebody knows something on StockTwits&#39;, &#39;reveal yourself&#39;, &#39;Why the drop I warren Buffet taking out his position&#39;, &#39;bears have reason on to pay more attention&#39;, &#39;ok good we re not dropping in price over the weekend lol&#39;, &#39;Daily Chart we need to get back to above&#39;, &#39;drop per week after spike if no news in months back to s if BO then bingo what is the odds&#39;], [4, 3, 4, 3, 2, 3, 0, 3, 4, 0]) . defaults.text_proc_rules . [&lt;function fastai.text.core.fix_html&gt;, &lt;function fastai.text.core.replace_rep&gt;, &lt;function fastai.text.core.replace_wrep&gt;, &lt;function fastai.text.core.spec_add_spaces&gt;, &lt;function fastai.text.core.rm_useless_spaces&gt;, &lt;function fastai.text.core.replace_all_caps&gt;, &lt;function fastai.text.core.replace_maj&gt;, &lt;function fastai.text.core.lowercase&gt;] . data = {&#39;messages&#39;: messages_clean, &#39;sentiments&#39;: sentiments} . df = pd.DataFrame(data); df.head() . messages sentiments . 0 great buy at ill wait | 4 | . 1 | 3 | . 2 STAAnalystAlert for Jefferies Maintains with a rating of Hold setting target price at USD Our own verdict is Buy | 4 | . 3 I heard there s a guy who knows someone who thinks somebody knows something on StockTwits | 3 | . 4 reveal yourself | 2 | . Remove blank messages . df = df[df[&#39;messages&#39;]!=&#39;&#39;] . df.head() . messages sentiments . 0 great buy at ill wait | 4 | . 2 STAAnalystAlert for Jefferies Maintains with a rating of Hold setting target price at USD Our own verdict is Buy | 4 | . 3 I heard there s a guy who knows someone who thinks somebody knows something on StockTwits | 3 | . 4 reveal yourself | 2 | . 5 Why the drop I warren Buffet taking out his position | 3 | . df.shape . (1500631, 2) . The first step of the ULMFit approach is to build a language model. A model that will predict the next word given the previous words. This is self supervized learning. So in a batch we have a text buffer as input and then the same buffer plus the next word as a target. . dls = TextDataLoaders.from_df(df, text_col=&#39;messages&#39;, label_col=&#39;sentiments&#39;, is_lm=True) dls.show_batch(max_n=3) . dls.show_batch(max_n=3) . text text_ . 0 xxbos funny how these bears comes out today where were you yesterday when i was all alone getting flamed by these young bulls xxbos holey moley batman xxbos holding my waiting for kiki to tell me she loves me i mean jcpenney xxbos xxmaj china s xxmaj zhoushan city woos xxmaj exxon xxmaj mobil for a billion ethylene plant xxbos is max pain xxbos they are overselling again bring that xxup rsi | funny how these bears comes out today where were you yesterday when i was all alone getting flamed by these young bulls xxbos holey moley batman xxbos holding my waiting for kiki to tell me she loves me i mean jcpenney xxbos xxmaj china s xxmaj zhoushan city woos xxmaj exxon xxmaj mobil for a billion ethylene plant xxbos is max pain xxbos they are overselling again bring that xxup rsi down | . 1 xxmaj volatility is expensive to forecast xxbos this is looking good xxbos wth xxbos about to break the daily high xxbos xxmaj all top ranks are xxup nvidia no others brands xxmaj see bounds back to xxbos people can run their fingers on the keyboard xxmaj xxunk and watch the chart you could learn a thing or two xxmaj now let s see premarket xxbos xxmaj update xxmaj aug xxmaj puts xxmaj | volatility is expensive to forecast xxbos this is looking good xxbos wth xxbos about to break the daily high xxbos xxmaj all top ranks are xxup nvidia no others brands xxmaj see bounds back to xxbos people can run their fingers on the keyboard xxmaj xxunk and watch the chart you could learn a thing or two xxmaj now let s see premarket xxbos xxmaj update xxmaj aug xxmaj puts xxmaj up | . 2 unitedhealth xxmaj group s xxup pt raised by xxmaj raymond xxmaj james to strong buy rating xxbos xxmaj great summary of xxmaj boyar xxmaj value xxmaj group s xxmaj letter stay clear of xxup faang xxbos xxmaj absolutely ridiculous xxbos pump fake xxbos waiting to head to xxbos xxmaj it amuses me when bears here think they control the price with xxup st messages xxbos if i m wrong i m wrong | xxmaj group s xxup pt raised by xxmaj raymond xxmaj james to strong buy rating xxbos xxmaj great summary of xxmaj boyar xxmaj value xxmaj group s xxmaj letter stay clear of xxup faang xxbos xxmaj absolutely ridiculous xxbos pump fake xxbos waiting to head to xxbos xxmaj it amuses me when bears here think they control the price with xxup st messages xxbos if i m wrong i m wrong i | . With this data we can now fine tune the language model. We will be using a recurrent neural network (RNN) using an architecture called AWD-LSTM . learn = language_model_learner( dls, AWD_LSTM, drop_mult=0.3, metrics=[accuracy, Perplexity()]).to_fp16() . learn.fit_one_cycle(1, 2e-2) . epoch train_loss valid_loss accuracy perplexity time . 0 | 3.973730 | 3.781465 | 0.368648 | 43.880272 | 19:35 | . learn.load(&#39;1epoch&#39;) . Path(&#39;models&#39;) . learn.unfreeze() learn.fit_one_cycle(10, 2e-3) . epoch train_loss valid_loss accuracy perplexity time . 0 | 3.667701 | 3.579307 | 0.391628 | 35.848701 | 22:17 | . 1 | 3.556901 | 3.493224 | 0.401178 | 32.891827 | 22:18 | . 2 | 3.501796 | 3.440667 | 0.407269 | 31.207756 | 22:08 | . 3 | 3.429217 | 3.405697 | 0.411324 | 30.135296 | 21:58 | . 4 | 3.346377 | 3.383271 | 0.414011 | 29.466999 | 22:09 | . 5 | 3.297989 | 3.370040 | 0.416521 | 29.079689 | 22:22 | . 6 | 3.222261 | 3.362387 | 0.418393 | 28.858006 | 22:10 | . 7 | 3.179726 | 3.362380 | 0.419272 | 28.857779 | 22:16 | . 8 | 3.155103 | 3.368545 | 0.419497 | 29.036251 | 22:22 | . 9 | 3.091218 | 3.374530 | 0.419274 | 29.210562 | 22:23 | . learn.summary() . epoch train_loss valid_loss accuracy perplexity time . 0 | None | None | None | 00:00 | . SequentialRNN (Input shape: [&#39;64 x 72&#39;]) ================================================================ Layer (type) Output Shape Param # Trainable ================================================================ RNNDropout 64 x 72 x 400 0 False ________________________________________________________________ RNNDropout 64 x 72 x 1152 0 False ________________________________________________________________ RNNDropout 64 x 72 x 1152 0 False ________________________________________________________________ Linear 64 x 72 x 39784 15,953,384 True ________________________________________________________________ RNNDropout 64 x 72 x 400 0 False ________________________________________________________________ Total params: 15,953,384 Total trainable params: 15,953,384 Total non-trainable params: 0 Optimizer used: &lt;function Adam at 0x7fc7a15836a8&gt; Loss function: FlattenedLoss of CrossEntropyLoss() Model frozen up to parameter group #3 Callbacks: - ModelResetter - RNNRegularizer - ModelToHalf - TrainEvalCallback - Recorder - ProgressCallback - MixedPrecision . We now have a language model originally trained on Wikipedia data trained with Stocktwits data. The goal is to predict the sentiment of messages but lets look at what this basic language model has learned . TEXT = &quot;Earnings were above expectations. This stock should be trending up.&quot; N_WORDS = 40 N_SENTENCES = 2 preds = [learn.predict(TEXT, N_WORDS, temperature=0.75) for _ in range(N_SENTENCES)] . print(&quot; n&quot;.join(preds)) . Earnings were above expectations xxunk This stock should be trending up xxunk Update Aug Calls Up to per contract since alerted on Jul days to expire Some of todays top open interest changes Update Sep Puts Up sincealerted on Earnings were above expectations xxunk This stock should be trending up xxunk Lot of Buying New Insider Filing On THICC JOHN days Transaction Code Both the short term and long term trends are positive This is a very . We now train our model with the sentiment label now using our language model as a starting point. . dls_clas = TextDataLoaders.from_df(df, text_col=&#39;messages&#39;, label_col=&#39;sentiments&#39;, is_lm=False) dls_clas.show_batch(max_n=3) . text category . 0 xxbos i xxup want xxup him xxup to xxup feel xxup max xxup pain xxup the xxup rest xxup ill xxup play xxup by xxup play xxup it xxup same xxup as xxup amd xxup at xxup exp xxup why xxup it xxup had xxup to xxup hit xxup then xxup it xxup did xxup lulu xxup wk b xxup ibm b | 0 | . 1 xxbos xxup the xxup xxunk xxup fucks xxup are xxup waiting xxup for xxup mu xxup to xxup go xxup below xxup to xxup buy xxup it xxup back xxup lets xxup just xxup all xxup max xxup out xxup our xxup credit xxup cards xxup and xxup buy xxup more xxup mu xxup at xxup this xxup low xxpad xxpad xxpad | 4 | . 2 xxbos lookslike xxmaj about xxup mm s xxmaj trying xxmaj to xxmaj hold xxup bid xxmaj in xxmaj low s xxmaj but xxup mm xxmaj forcing xxmaj trading xxmaj in xxmaj low s xxup jpm xxmaj tusa lol xxmaj glta xxmaj bulls xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad | 4 | . torch.save(dls_clas, &#39;./models/dls_clas1.pkl&#39;) . dls_clas = torch.load(&#39;./models/dls_clas1.pkl&#39;) . dls_clas.show_batch(max_n=3) . text category . 0 xxbos i xxup want xxup him xxup to xxup feel xxup max xxup pain xxup the xxup rest xxup ill xxup play xxup by xxup play xxup it xxup same xxup as xxup amd xxup at xxup exp xxup why xxup it xxup had xxup to xxup hit xxup then xxup it xxup did xxup lulu xxup wk b xxup ibm b | 0 | . 1 xxbos xxup the xxup xxunk xxup fucks xxup are xxup waiting xxup for xxup mu xxup to xxup go xxup below xxup to xxup buy xxup it xxup back xxup lets xxup just xxup all xxup max xxup out xxup our xxup credit xxup cards xxup and xxup buy xxup more xxup mu xxup at xxup this xxup low xxpad xxpad xxpad | 4 | . 2 xxbos lookslike xxmaj about xxup mm s xxmaj trying xxmaj to xxmaj hold xxup bid xxmaj in xxmaj low s xxmaj but xxup mm xxmaj forcing xxmaj trading xxmaj in xxmaj low s xxup jpm xxmaj tusa lol xxmaj glta xxmaj bulls xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad xxpad | 4 | . learn = text_classifier_learner(dls_clas, AWD_LSTM, drop_mult=0.5, metrics=accuracy).to_fp16() . . learn.fit_one_cycle(1, 2e-2) . epoch train_loss valid_loss accuracy time . 0 | 1.415620 | 1.161403 | 0.529711 | 14:30 | . learn.freeze_to(-2) learn.fit_one_cycle(1, slice(1e-2/(2.6**4),1e-2)) . epoch train_loss valid_loss accuracy time . 0 | 0.976749 | 0.891179 | 0.661879 | 15:38 | . learn.freeze_to(-3) learn.fit_one_cycle(1, slice(5e-3/(2.6**4),5e-3)) . epoch train_loss valid_loss accuracy time . 0 | 0.819692 | 0.752725 | 0.720497 | 16:02 | . learn.unfreeze() learn.fit_one_cycle(10, slice(1e-3/(2.6**4),1e-3)) . epoch train_loss valid_loss accuracy time . 0 | 0.777341 | 0.734695 | 0.725702 | 16:32 | . 1 | 0.743741 | 0.660567 | 0.757402 | 16:44 | . 2 | 0.675439 | 0.628990 | 0.769650 | 16:24 | . 3 | 0.640707 | 0.613024 | 0.775841 | 16:08 | . 4 | 0.641090 | 0.602056 | 0.779922 | 15:50 | . 5 | 0.630175 | 0.593337 | 0.782618 | 15:47 | . 6 | 0.622346 | 0.590662 | 0.783731 | 15:44 | . 7 | 0.604861 | 0.592279 | 0.783621 | 15:49 | . 8 | 0.596378 | 0.589263 | 0.785593 | 15:58 | . 9 | 0.574639 | 0.588258 | 0.784964 | 16:14 | . learn.save(&#39;after_10&#39;) . Path(&#39;models/after_10.pth&#39;) . . . epoch train_loss valid_loss accuracy time . 0 | 0.645871 | 0.596121 | 0.779313 | 17:46 | . 1 | 0.619049 | 0.588018 | 0.783184 | 17:38 | . . . epoch train_loss valid_loss accuracy time . 0 | 0.633412 | 0.585391 | 0.784041 | 16:58 | . 1 | 0.604094 | 0.582888 | 0.785810 | 17:04 | . . epoch train_loss valid_loss accuracy time . 0 | 0.597683 | 0.584122 | 0.784780 | 17:19 | . 1 | 0.587458 | 0.580067 | 0.788212 | 17:29 | . learn.fit_one_cycle(2, slice(1e-3/(2.6**4),1e-3)) . epoch train_loss valid_loss accuracy time . 0 | nan | 00:00 | . /usr/local/lib/python3.6/dist-packages/fastprogress/fastprogress.py:74: UserWarning: Your generator is empty. warn(&#34;Your generator is empty.&#34;) . AttributeError Traceback (most recent call last) &lt;ipython-input-46-dff58193d9a6&gt; in &lt;module&gt;() -&gt; 1 learn.fit_one_cycle(2, slice(1e-3/(2.6**4),1e-3)) /usr/local/lib/python3.6/dist-packages/fastcore/logargs.py in _f(*args, **kwargs) 54 init_args.update(log) 55 setattr(inst, &#39;init_args&#39;, init_args) &gt; 56 return inst if to_return else f(*args, **kwargs) 57 return _f /usr/local/lib/python3.6/dist-packages/fastai/callback/schedule.py in fit_one_cycle(self, n_epoch, lr_max, div, div_final, pct_start, wd, moms, cbs, reset_opt) 111 scheds = {&#39;lr&#39;: combined_cos(pct_start, lr_max/div, lr_max, lr_max/div_final), 112 &#39;mom&#39;: combined_cos(pct_start, *(self.moms if moms is None else moms))} --&gt; 113 self.fit(n_epoch, cbs=ParamScheduler(scheds)+L(cbs), reset_opt=reset_opt, wd=wd) 114 115 # Cell /usr/local/lib/python3.6/dist-packages/fastcore/logargs.py in _f(*args, **kwargs) 54 init_args.update(log) 55 setattr(inst, &#39;init_args&#39;, init_args) &gt; 56 return inst if to_return else f(*args, **kwargs) 57 return _f /usr/local/lib/python3.6/dist-packages/fastai/learner.py in fit(self, n_epoch, lr, wd, cbs, reset_opt) 205 self.opt.set_hypers(lr=self.lr if lr is None else lr) 206 self.n_epoch = n_epoch --&gt; 207 self._with_events(self._do_fit, &#39;fit&#39;, CancelFitException, self._end_cleanup) 208 209 def _end_cleanup(self): self.dl,self.xb,self.yb,self.pred,self.loss = None,(None,),(None,),None,None /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 153 154 def _with_events(self, f, event_type, ex, final=noop): --&gt; 155 try: self(f&#39;before_{event_type}&#39;) ;f() 156 except ex: self(f&#39;after_cancel_{event_type}&#39;) 157 finally: self(f&#39;after_{event_type}&#39;) ;final() /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _do_fit(self) 195 for epoch in range(self.n_epoch): 196 self.epoch=epoch --&gt; 197 self._with_events(self._do_epoch, &#39;epoch&#39;, CancelEpochException) 198 199 @log_args(but=&#39;cbs&#39;) /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 153 154 def _with_events(self, f, event_type, ex, final=noop): --&gt; 155 try: self(f&#39;before_{event_type}&#39;) ;f() 156 except ex: self(f&#39;after_cancel_{event_type}&#39;) 157 finally: self(f&#39;after_{event_type}&#39;) ;final() /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _do_epoch(self) 189 190 def _do_epoch(self): --&gt; 191 self._do_epoch_train() 192 self._do_epoch_validate() 193 /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _do_epoch_train(self) 181 def _do_epoch_train(self): 182 self.dl = self.dls.train --&gt; 183 self._with_events(self.all_batches, &#39;train&#39;, CancelTrainException) 184 185 def _do_epoch_validate(self, ds_idx=1, dl=None): /usr/local/lib/python3.6/dist-packages/fastai/learner.py in _with_events(self, f, event_type, ex, final) 153 154 def _with_events(self, f, event_type, ex, final=noop): --&gt; 155 try: self(f&#39;before_{event_type}&#39;) ;f() 156 except ex: self(f&#39;after_cancel_{event_type}&#39;) 157 finally: self(f&#39;after_{event_type}&#39;) ;final() /usr/local/lib/python3.6/dist-packages/fastai/learner.py in all_batches(self) 159 def all_batches(self): 160 self.n_iter = len(self.dl) --&gt; 161 for o in enumerate(self.dl): self.one_batch(*o) 162 163 def _do_one_batch(self): /usr/local/lib/python3.6/dist-packages/fastai/data/load.py in __iter__(self) 99 self.randomize() 100 self.before_iter() --&gt; 101 self.__idxs=self.get_idxs() # called in context of main process (not workers/subprocesses) 102 for b in _loaders[self.fake_l.num_workers==0](self.fake_l): 103 if self.device is not None: b = to_device(b, self.device) /usr/local/lib/python3.6/dist-packages/fastai/text/data.py in get_idxs(self) 163 164 def get_idxs(self): --&gt; 165 idxs = super().get_idxs() 166 if self.shuffle: return idxs 167 return sorted(idxs, key=lambda i: self.res[i], reverse=True) /usr/local/lib/python3.6/dist-packages/fastai/data/load.py in get_idxs(self) 90 idxs = Inf.count if self.indexed else Inf.nones 91 if self.n is not None: idxs = list(itertools.islice(idxs, self.n)) &gt; 92 if self.shuffle: idxs = self.shuffle_fn(idxs) 93 return idxs 94 /usr/local/lib/python3.6/dist-packages/fastai/text/data.py in shuffle_fn(self, idxs) 169 def shuffle_fn(self,idxs): 170 idxs = np.random.permutation(len(self.dataset)) --&gt; 171 idx_max = np.where(idxs==self.idx_max)[0][0] 172 idxs[0],idxs[idx_max] = idxs[idx_max],idxs[0] 173 sz = self.bs*50 /usr/local/lib/python3.6/dist-packages/fastcore/foundation.py in __getattr__(self, k) 157 if self._component_attr_filter(k): 158 attr = getattr(self,self._default,None) --&gt; 159 if attr is not None: return getattr(attr,k) 160 raise AttributeError(k) 161 def __dir__(self): return custom_dir(self,self._dir()) /usr/local/lib/python3.6/dist-packages/fastai/data/core.py in __getattr__(self, k) 315 return res if is_indexer(it) else list(zip(*res)) 316 --&gt; 317 def __getattr__(self,k): return gather_attrs(self, k, &#39;tls&#39;) 318 def __dir__(self): return super().__dir__() + gather_attr_names(self, &#39;tls&#39;) 319 def __len__(self): return len(self.tls[0]) /usr/local/lib/python3.6/dist-packages/fastcore/transform.py in gather_attrs(o, k, nm) 163 att = getattr(o,nm) 164 res = [t for t in att.attrgot(k) if t is not None] --&gt; 165 if not res: raise AttributeError(k) 166 return res[0] if len(res)==1 else L(res) 167 AttributeError: idx_max . learn.summary() . ValueError Traceback (most recent call last) &lt;ipython-input-38-bc39e9e85f86&gt; in &lt;module&gt;() -&gt; 1 learn.summary() /usr/local/lib/python3.6/dist-packages/fastai/callback/hook.py in summary(self) 186 def summary(self:Learner): 187 &#34;Print a summary of the model, optimizer and loss function.&#34; --&gt; 188 xb = self.dls.train.one_batch()[:self.dls.train.n_inp] 189 res = module_summary(self, *xb) 190 res += f&#34;Optimizer used: {self.opt_func} nLoss function: {self.loss_func} n n&#34; /usr/local/lib/python3.6/dist-packages/fastai/data/load.py in one_batch(self) 133 def to(self, device): self.device = device 134 def one_batch(self): --&gt; 135 if self.n is not None and len(self)==0: raise ValueError(f&#39;This DataLoader does not contain any batches&#39;) 136 with self.fake_l.no_multiproc(): res = first(self) 137 if hasattr(self, &#39;it&#39;): delattr(self, &#39;it&#39;) ValueError: This DataLoader does not contain any batches . learn.export(&#39;export2_1.pkl&#39;) . learn.predict(&#39;$AAPL doing my part. Just bought my first iPad&#39;) . (&#39;4&#39;, tensor(4), tensor([4.7856e-04, 2.6827e-02, 4.5500e-02, 5.6848e-02, 8.7035e-01])) . learn.predict(&#39;$AAPL historic reversal selloff on news , historic crash news&#39;) . (&#39;0&#39;, tensor(0), tensor([9.7967e-01, 2.6304e-04, 1.2899e-02, 7.1583e-03, 4.8937e-06])) . learn.predict(&#39;$AAPL well that was a good trade&#39;) . (&#39;2&#39;, tensor(2), tensor([0.0092, 0.0419, 0.7770, 0.1612, 0.0107])) . learn.predict(&#39;Sold my $AAPL 10/16 $120c this morning and MAN I&amp;#39;m glad I&amp;#39;m out of there! n nAlthough, this was one of my favorite trades, holding through the volatility last week was ROUGH and I didn&amp;#39;t want to be caught holding the bag (after the iPhone event) n nWhat&amp;#39;s next? since $SPY making a new high... Might looks for some shorts now üêªüêªüêª&#39;) . (&#39;3&#39;, tensor(3), tensor([4.4554e-04, 4.8995e-02, 3.4516e-01, 6.0069e-01, 4.7157e-03])) . learn.predict(&#39;$AAPL the news already leaked. Nothing new just a battery that last an extra hour and the 5G. They are going to launch 4 phones. Probably this time they will introduce the middle finger option to unlock the phone. To make the idiots happy that they brought something new. Lol&#39;) . (&#39;2&#39;, tensor(2), tensor([1.2910e-04, 1.0833e-02, 8.2918e-01, 1.5977e-01, 8.7016e-05])) .",
            "url": "https://sylvaint.github.io/aimusing/ai%20for%20trading/ulmfit/2020/10/20/fastai_ulmfit_vs_pytorch_stocktwits.html",
            "relUrl": "/ai%20for%20trading/ulmfit/2020/10/20/fastai_ulmfit_vs_pytorch_stocktwits.html",
            "date": " ‚Ä¢ Oct 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a ‚Äúlevel 1 heading‚Äù in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here‚Äôs a footnote 1. Here‚Äôs a horizontal rule: . . Lists . Here‚Äôs a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes ‚Ä¶and‚Ä¶ . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote.¬†&#8617; . |",
            "url": "https://sylvaint.github.io/aimusing/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " ‚Ä¢ Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats.¬†&#8617; . |",
          "url": "https://sylvaint.github.io/aimusing/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://sylvaint.github.io/aimusing/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}